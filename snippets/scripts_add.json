{

"Backtesting start/end â‡¨ ð‘“ð‘¥": {
  "prefix": "f.backtesting",
  "body": [
    "// # ========================= Backtesting Inputs ============================ #",
    "Start_date                  = input.int(defval = 1    , title = \"Day âž¡\"   , minval = 1    , maxval = 31   , inline = \"00\"  , group = \"â± Backtesting Start â±\")",
    "Start_month                 = input.int(defval = 1    , title = \"Month âž¡\" , minval = 1    , maxval = 12   , inline = \"00\"  , group = \"â± Backtesting Start â±\")",
    "Start_year                  = input.int(defval = 2000 , title = \"Year âž¡\"  , minval = 2000 , maxval = 2100 , inline = \"00\"  , group = \"â± Backtesting Start â±\")",
    "",
    "End_date                    = input.int(defval = 1    , title = \"Day âž¡\"   , minval = 1    , maxval = 31   , inline = \"01\"  , group = \"â±  Backtesting End  â±\")",
    "End_month                   = input.int(defval = 1    , title = \"Month âž¡\" , minval = 1    , maxval = 12   , inline = \"01\"  , group = \"â±  Backtesting End  â±\")",
    "End_year                    = input.int(defval = 2030 , title = \"Year âž¡\"  , minval = 2000 , maxval = 2100 , inline = \"01\"  , group = \"â±  Backtesting End  â±\")",
    "// # ========================= Backtesting Inputs ============================ #",
    "",
    "// # ======================= Backtesting Calculation ========================= #",
    "backtesting                 = (time >= timestamp(syminfo.timezone, Start_year, Start_month, Start_date, 0, 0)) and (time <= timestamp(syminfo.timezone, End_year, End_month, End_date, 0, 0))",
    "// # ======================= Backtesting Calculation ========================= #",
    "",
    "$0",
    ""
  ],
  "description": "Backtesting start/end"
},

"Bollinger Bands different MA's â‡¨ ð‘“ð‘¥": {
  "prefix": "f.bb",
  "body": [
    "// # ============================== BB Inputs ================================ #",
    "BB_source                   = input.source( defval = close  , title = \"Source\"                                                , inline = \"00\" , group = \"ðŸ”µ Bollinger Bands ðŸ”µ\")",
    "BB_MA                       = input.string( defval = \"SMA\"  , title = \"MA Source\" , options = [\"RMA\" , \"SMA\" , \"EMA\" , \"WMA\"] , inline = \"00\" , group = \"ðŸ”µ Bollinger Bands ðŸ”µ\")",
    "BB_length                   = input.int(    defval = 20     , title = \"Length\"    , minval = 1                                , inline = \"01\" , group = \"ðŸ”µ Bollinger Bands ðŸ”µ\")",
    "BB_Multiplicator            = input.float(  defval = 2.0    , title = \"STD\"       , minval = 0.001   , maxval = 50            , inline = \"01\" , group = \"ðŸ”µ Bollinger Bands ðŸ”µ\")",
    "BB_offset                   = input.int(    defval = 0      , title = \"Offset\"    , minval = -500    , maxval = 500           , inline = \"01\" , group = \"ðŸ”µ Bollinger Bands ðŸ”µ\")",
    "// # ============================== BB Inputs ================================ #",
    "",
    "// # =========================== BB Calculation ============================== #",
    "bb_ma_function(source, length)  =>",
    "    if BB_MA ==  \"RMA\"",
    "        ta.rma(source, length)",
    "    else",
    "        if BB_MA ==  \"SMA\"",
    "            ta.sma(source, length)",
    "        else",
    "            if BB_MA ==  \"EMA\"",
    "                ta.ema(source, length)",
    "            else",
    "                ta.wma(source, length)",
    "",
    "BB_basis                    = bb_ma_function(BB_source, BB_length)",
    "BB_std                      = BB_Multiplicator * ta.stdev(source = BB_source, length = BB_length)",
    "BB_upper                    = BB_basis + BB_std",
    "BB_lower                    = BB_basis - BB_std",
    "// # =========================== BB Calculation ============================== #",
    "",
    "${1:// # ============================= BB Plotting =============================== #",
    "plot(series = BB_basis, title = \"Basis\", color  = color.new(#FF6D00, 0), offset = BB_offset)",
    "p1                          = plot(series = BB_upper, title = \"Upper\", color = color.new(#2962FF, 0), offset = BB_offset)",
    "p2                          = plot(series = BB_lower, title = \"Lower\", color = color.new(#2962FF, 0), offset = BB_offset)",
    "fill(plot1 = p1, plot2 = p2, title = \"Background\", color = color.rgb(33, 150, 243, 95))",
    "// # ============================= BB Plotting =============================== #}"
  ],
  "description": "Bollinger Bands different MA's"
},

"Trailing SL & TP â‡¨ ð‘“ð‘¥": {
  "prefix": "f.stoploss",
  "body": [
    "",
    "// â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’* STOP LOSS *â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’",
    "// # ======================== percent2point inputs =========================== #",
    "percent2points(percent) => strategy.position_avg_price * percent / 100 / syminfo.mintick",
    "",
    "ActivateStopLoss  = input.bool( defval = true  , title = \"Activate Stoploss\"                                        , inline = \"00\" , group = \"â›” SL & TP â›”\")",
    "sl_input          = input.int(  defval = 5     , title = \"SL %\"                                                     , inline = \"01\" , group = \"â›” SL & TP â›”\")",
    "tp1_input         = input.int(  defval = 5     , title = \"TP 1 %\"                                                   , inline = \"01\" , group = \"â›” SL & TP â›”\")",
    "tp2_input         = input.int(  defval = 10    , title = \"TP 2 %\"                                                   , inline = \"01\" , group = \"â›” SL & TP â›”\")",
    "tp3_input         = input.int(  defval = 15    , title = \"TP 3 %\"                                                   , inline = \"01\" , group = \"â›” SL & TP â›”\")",
    "trailing_bool     = input.bool( defval = false , title = \"Activate Trailing -> TP3 is amount, TP 2 is offset level\" , inline = \"03\" , group = \"â›” SL & TP â›”\")",
    "// # ======================== percent2point inputs =========================== #",
    "",
    "// # =========================== SL Calculation ============================== #",
    "sl                = percent2points( sl_input  )",
    "tp1               = percent2points( tp1_input )",
    "tp2               = percent2points( tp2_input )",
    "tp3               = percent2points( tp3_input )",
    "",
    "curProfitInPts() =>",
    "    if strategy.position_size > 0",
    "        (high - strategy.position_avg_price) / syminfo.mintick",
    "    else if strategy.position_size < 0",
    "        (strategy.position_avg_price - low) / syminfo.mintick",
    "    else",
    "        0    ",
    "",
    "calcStopLossPrice(OffsetPts) =>",
    "    if strategy.position_size > 0",
    "        strategy.position_avg_price - OffsetPts * syminfo.mintick",
    "    else if strategy.position_size < 0",
    "        strategy.position_avg_price + OffsetPts * syminfo.mintick",
    "    else",
    "        na        ",
    "",
    "calcProfitTrgtPrice(OffsetPts) =>",
    "    calcStopLossPrice(-OffsetPts)",
    "",
    "getCurrentStage() =>",
    "    var stage = 0",
    "    if strategy.position_size == 0 ",
    "        stage := 0",
    "    if stage == 0 and strategy.position_size != 0",
    "        stage := 1",
    "    else if stage == 1 and curProfitInPts() >= tp1",
    "        stage := 2",
    "    else if stage == 2 and curProfitInPts() >= tp2",
    "        stage := 3",
    "    stage",
    "",
    "calcTrailingAmountLevel(points) =>",
    "    var float level = na",
    "    level := calcProfitTrgtPrice(points)",
    "    if not na(level)",
    "        if strategy.position_size > 0",
    "            if not na(level[1])",
    "                level := max(level[1], level)",
    "            if not na(level)",
    "                level := max(high, level)",
    "        else if strategy.position_size < 0",
    "            if not na(level[1])",
    "                level := min(level[1], level)",
    "            if not na(level)",
    "                level := min(low, level)",
    "",
    "calcTrailingOffsetLevel(points, offset) =>",
    "    float result = na",
    "    amountLevel = calcTrailingAmountLevel(points)",
    "    if strategy.position_size > 0",
    "        trailActiveDiff = amountLevel - calcProfitTrgtPrice(points)",
    "        if trailActiveDiff > 0",
    "            result := trailActiveDiff + calcProfitTrgtPrice(offset)",
    "    else if strategy.position_size < 0",
    "        trailActiveDiff = calcProfitTrgtPrice(points) - amountLevel",
    "        if trailActiveDiff > 0",
    "            result := calcProfitTrgtPrice(offset) - trailActiveDiff",
    "    result",
    "",
    "float stopLevel = na",
    "float trailOffsetLevel = na",
    "float profitLevel = trailing_bool ? calcTrailingAmountLevel(tp3) : calcProfitTrgtPrice(tp3)",
    "",
    "trailOffsetLevelTmp = calcTrailingOffsetLevel(tp3, tp2)",
    "",
    "curStage = getCurrentStage()",
    "if ActivateStopLoss",
    "   if curStage == 1",
    "       stopLevel := calcStopLossPrice(sl)",
    "       strategy.exit(\"${1:ID LONG}\", loss = sl, profit = tp3, comment = \"SL or TP 3\")${2:",
    "       strategy.exit(\"${3:ID SHORT}\", loss = sl, profit = tp3, comment = \"SL or TP 3\")}",
    "   else if curStage == 2",
    "       stopLevel := calcStopLossPrice(0)",
    "       strategy.exit(\"$1\", stop = stopLevel, profit = tp3, comment = \"BH or TP 3\")${4:",
    "       strategy.exit(\"$3\", stop = stopLevel, profit = tp3, comment = \"BH or TP 3\")}",
    "   else if curStage == 3",
    "       stopLevel := calcStopLossPrice(-tp1)",
    "       if trailing_bool",
    "           trailOffsetLevel := trailOffsetLevelTmp",
    "           strategy.exit(\"$1\", stop = stopLevel, trail_points = tp3, trail_offset = tp3-tp2, comment = \"stop tp1 or trailing tp3 with offset tp2\")${5:",
    "           strategy.exit(\"$3\", stop = stopLevel, trail_points = tp3, trail_offset = tp3-tp2, comment = \"stop tp1 or trailing tp3 with offset tp2\")}",
    "       else",
    "           strategy.exit(\"$1\", stop = stopLevel, profit = tp3, comment = \"tp1 or tp3\")${6:",
    "           strategy.exit(\"$3\", stop = stopLevel, profit = tp3, comment = \"tp1 or tp3\")}",
    "   else",
    "       strategy.cancel(\"$1\")${7:",
    "       strategy.cancel(\"$3\")}",
    "// # =========================== SL Calculation ============================== #${8:",
    "// URL https://www.tradingview.com/script/jjhUHcje-Stepped-trailing-strategy-example/}",
    "// â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’* STOP LOSS *â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’",
    "$0"
  ],
  "description": "Trailing SL & TP"
}



}